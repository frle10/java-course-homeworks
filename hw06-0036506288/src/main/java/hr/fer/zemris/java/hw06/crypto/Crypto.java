package hr.fer.zemris.java.hw06.crypto;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Scanner;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * Allows the user to encrypt/decrypt given file using the AES crypto-algorithm and the
 * 128-bit encryption key and check the SHA-256 file digest.
 * 
 * @author Ivan Skorupan
 */
public class Crypto {

	/**
	 * Number of bytes generated by SHA-256 digest.
	 */
	private static final int SHA_256_DIGEST_LENGTH = 32;

	/**
	 * Entry point when starting the program.
	 * 
	 * @param args - command line arguments
	 */
	public static void main(String[] args) {
		// check arguments validity
		try {
			checkArguments(args);
		} catch(IllegalArgumentException ex) {
			// in case the command line input is not valid, print an appropriate message to user and exit the program
			System.out.println(ex.getMessage());
			System.exit(-1);
		}
		
		// get command name and path to input file
		String command = args[0];
		Path inputFilePath = Paths.get(args[1]);
		Scanner scanner = new Scanner(System.in);

		// check which command the user enetered and then execute it
		if(command.equals("checksha")) {
			System.out.println("Please provide expected sha-256 digest for " + inputFilePath.getFileName() + ":");
			System.out.print("> ");
			
			// get the expected file digest from user
			String expectedDigest = getInput(scanner);

			byte[] digest = new byte[SHA_256_DIGEST_LENGTH];
			// digest the file
			try {
				digest = digestFile(inputFilePath);
			} catch (NoSuchAlgorithmException | IOException e) {
				// in case there is a problem while digesting the file, print an appropriate message to user and exit the program
				System.out.println("There was an error while trying to digest the given file!");
				System.exit(-1);
			}
			
			// get the digest hex-string from generated bytes
			String hexDigest = Util.byteToHex(digest);
			
			System.out.print("Digesting completed. ");
			// test expected and generated digest equality and print success/failure message
			if(expectedDigest.equals(hexDigest)) {
				System.out.println("Digest of " + inputFilePath.getFileName() + " matches expected digest.");
			} else {
				System.out.println("Digest of " + inputFilePath.getFileName() + " does not match the expected digest. Digest was: " + hexDigest);
			}
		} else if(command.equals("encrypt") || command.equals("decrypt")) {
			// get the path for output file
			Path outputFilePath = Paths.get(args[2]);
			System.out.println("Please provide password as hex-encoded text (16 bytes, i.e. 32 hex-digits):");
			System.out.print("> ");
			// get key from user
			String keyText = getInput(scanner);
			
			System.out.println("Please provide initialization vector as hex-encoded text (32 hex-digits):");
			System.out.print("> ");
			// get initialization vector from user
			String ivText = getInput(scanner);
			
			// encrypt or decrypt the file (depending on entered command)
			boolean encrypt = command.equals("encrypt") ? true : false;
			try {
				encryptOrDecryptFile(inputFilePath, outputFilePath, keyText, ivText, encrypt);
			} catch (Exception e) {
				// in case there is an error, print an appropriate message to user and exit the program
				System.out.println("There was an error while " + command + "ing the file " + inputFilePath.getFileName() + ". The message was: " + e.getMessage());
				System.exit(-1);
			}
			
			// print success message
			String operation = command.equals("encrypt") ? "Encryption" : "Decryption";
			System.out.println(operation + " completed. Generated file " + outputFilePath.getFileName() + " based on file " + inputFilePath.getFileName() + ".");
		}
		
		// close the input scanner
		scanner.close();
	}
	
	/**
	 * Encrypts or decrypts a file given by its <code>inputFilePath</code> using the provided <code>keyText</code> and
	 * <code>ivText</code>.
	 * <p>
	 * Algorithm used is AES/CBC/PKCS5Padding.
	 * <p>
	 * The resulting file is saved to <code>outputFilePath</code>.
	 * <p>
	 * Encryption and decryption mode is controlled using the <code>encrypt</code> argument. If it is equal to <code>true</code>,
	 * this method encrypts the file, if it is equal to <code>false</code>, it decrypts the file.
	 * 
	 * @param inputFilePath - path of the file that needs to be encrypted/decrypted
	 * @param outputFilePath - path of the output file (where the encryption/decryption result will be saved)
	 * @param keyText - public key used for AES algorithm
	 * @param ivText - initialization vector
	 * @param encrypt - boolean which, if <code>true</code>, signals encryption operation, if <code>false</code>, it signals decryption operation
	 * @throws NoSuchAlgorithmException if internally provided algorithm string is not supported
	 * @throws NoSuchPaddingException if requested padding mechanism is not available in the environment
	 * @throws InvalidKeyException if provided key is not valid
	 * @throws InvalidAlgorithmParameterException if algorithm parameters are invalid or inappropriate
	 * @throws IOException if there was an error reading or writing to files
	 * @throws ShortBufferException if output buffer is too short to contain the operation result
	 * @throws IllegalBlockSizeException if length of data provided to a block cipher is incorrect
	 * @throws BadPaddingException if input data is not padded properly for a particular padding mechanism
	 */
	private static void encryptOrDecryptFile(Path inputFilePath, Path outputFilePath, String keyText, String ivText, boolean encrypt) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IOException, ShortBufferException, IllegalBlockSizeException, BadPaddingException {
		SecretKeySpec keySpec = new SecretKeySpec(Util.hexToByte(keyText), "AES");
		AlgorithmParameterSpec paramSpec = new IvParameterSpec(Util.hexToByte(ivText));
		Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
		cipher.init(encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, keySpec, paramSpec);
		
		try(InputStream is = new BufferedInputStream(Files.newInputStream(inputFilePath));
				OutputStream os = new BufferedOutputStream(Files.newOutputStream(outputFilePath))) {
			byte[] buffer = new byte[128];
			
			while(true) {
				int r = is.read(buffer);
				if(r < 1) break;
				byte[] output = cipher.update(buffer, 0, r);
				if(output == null) {
					continue;
				}
				os.write(output, 0, output.length);
			}
			
			byte[] output = cipher.doFinal();
			if(output != null) {
				os.write(output, 0, output.length);
			}
		}
	}
	
	/**
	 * Gets and returns user input using the provided <code>scanner</code>.
	 * 
	 * @param scanner - a {@link Scanner} object to use for input
	 * @return user input string
	 */
	private static String getInput(Scanner scanner) {
		if(scanner.hasNext()) {
			return scanner.next();
		}
		
		return "";
	}

	/**
	 * Digests the given file and returns the calculated digest as an array of bytes.
	 * 
	 * @param inputFilePath - path of the input file
	 * @return a byte array containing the calculated digest
	 * @throws NoSuchAlgorithmException if {@link MessageDigest#getInstance(String) getInstance()} method gets an unsupported algorithm string
	 * @throws IOException if there was an error reading the input file
	 */
	private static byte[] digestFile(Path inputFilePath) throws NoSuchAlgorithmException, IOException {
		MessageDigest digest = MessageDigest.getInstance("SHA-256");

		try(InputStream is = new BufferedInputStream(Files.newInputStream(inputFilePath))) {
			byte[] buffer = new byte[128];
			while(true) {
				int r = is.read(buffer);
				if(r < 1) break;
				digest.update(buffer, 0, r);
			}
		}

		return digest.digest();
	}

	/**
	 * Checks if command-line arguments are valid.
	 * <p>
	 * Otherwise, throws an {@link IllegalArgumentException}.
	 * 
	 * @param args - command line arguments
	 * @throws IllegalArgumentException if arguments are invalid
	 */
	private static void checkArguments(String[] args) {
		if(args.length < 1) {
			throw new IllegalArgumentException("Program expects at least one argument!");
		}

		String command = args[0];
		if(command.equals("checksha")) {
			if(args.length != 2) {
				throw new IllegalArgumentException("Command " + command + " expects exactly one argument!");
			}
		} else if(command.equals("encrypt") || command.equals("decrypt")) {
			if(args.length != 3) {
				throw new IllegalArgumentException("Commmand " + command + "expects exactly two arguments!");
			}
		} else {
			throw new IllegalArgumentException("An unsupported command was entered!");
		}
	}

}
